-- Função Genérica de Atualização de Timestamp
CREATE OR REPLACE FUNCTION public.fn_atualiza_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.atualizado_em = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- --------------------------------------------------------
-- TABELA: USERS
-- --------------------------------------------------------
CREATE TABLE public.users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    categoria VARCHAR(20) NOT NULL,
    cpf VARCHAR(11) UNIQUE NOT NULL,
    senha VARCHAR(255) NOT NULL,
    ic_ativo CHAR(1) DEFAULT 'S' NOT NULL,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT ck_users_categoria CHECK (categoria IN ('ADMIN', 'SINDICO', 'MORADOR', 'FUNCIONARIO')),
    CONSTRAINT ck_users_cpf_tamanho CHECK (LENGTH(cpf) = 11),
    CONSTRAINT ck_users_ic_ativo CHECK (ic_ativo IN ('S', 'N'))
);

COMMENT ON TABLE public.users IS 'Armazena os dados de autenticação e credenciais do sistema. Tamanho inicial estimado: 100 registros. Crescimento anual estimado: 5%.';
COMMENT ON COLUMN public.users.id IS 'Identificador artificial único do usuário.';
COMMENT ON COLUMN public.users.categoria IS 'Define o nível de acesso. Valores permitidos: ADMIN, SINDICO, MORADOR, FUNCIONARIO.';
COMMENT ON COLUMN public.users.cpf IS 'Número do Cadastro de Pessoas Físicas, utilizado como login.';
COMMENT ON COLUMN public.users.senha IS 'Senha de acesso criptografada do usuário.';
COMMENT ON COLUMN public.users.ic_ativo IS 'Indicador de exclusão lógica. S para ativo, N para inativo.';
COMMENT ON COLUMN public.users.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.users.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_users_atualizado_em
BEFORE UPDATE ON public.users
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();

-- --------------------------------------------------------
-- TABELA: LOCAIS
-- --------------------------------------------------------
CREATE TABLE public.locais (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100) UNIQUE NOT NULL,
    capacidade INTEGER NOT NULL,
    ic_ativo CHAR(1) DEFAULT 'S' NOT NULL,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT ck_locais_capacidade CHECK (capacidade > 0),
    CONSTRAINT ck_locais_ic_ativo CHECK (ic_ativo IN ('S', 'N'))
);

COMMENT ON TABLE public.locais IS 'Áreas comuns disponíveis para reserva no condomínio (ex: Churrasqueira, Salão de Festas). Tamanho inicial estimado: 10 registros. Crescimento anual estimado: 0%.';
COMMENT ON COLUMN public.locais.id IS 'Identificador artificial único do local.';
COMMENT ON COLUMN public.locais.nome IS 'Nome de identificação da área comum.';
COMMENT ON COLUMN public.locais.capacidade IS 'Número máximo de pessoas permitidas no local.';
COMMENT ON COLUMN public.locais.ic_ativo IS 'Indicador de exclusão lógica. S para ativo, N para inativo.';
COMMENT ON COLUMN public.locais.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.locais.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_locais_atualizado_em
BEFORE UPDATE ON public.locais
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();

-- --------------------------------------------------------
-- TABELA: FUNCIONARIOS
-- --------------------------------------------------------
CREATE TABLE public.funcionarios (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fk_user BIGINT UNIQUE REFERENCES public.users(id) ON DELETE SET NULL,
    nome VARCHAR(150) NOT NULL,
    cargo VARCHAR(100) NOT NULL,
    cpf VARCHAR(11) UNIQUE NOT NULL,
    rg VARCHAR(20) UNIQUE NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    telefone NUMERIC(11,0) NOT NULL,
    ic_ativo CHAR(1) DEFAULT 'S' NOT NULL,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT ck_funcionarios_email CHECK (email LIKE '%@%'),
    CONSTRAINT ck_funcionarios_ic_ativo CHECK (ic_ativo IN ('S', 'N'))
);

COMMENT ON TABLE public.funcionarios IS 'Cadastro detalhado dos funcionários do condomínio e portaria. Tamanho inicial estimado: 20 registros. Crescimento anual estimado: 10%.';
COMMENT ON COLUMN public.funcionarios.id IS 'Identificador artificial único do funcionário.';
COMMENT ON COLUMN public.funcionarios.fk_user IS 'Chave estrangeira que vincula o funcionário aos seus dados de login.';
COMMENT ON COLUMN public.funcionarios.nome IS 'Nome completo do funcionário.';
COMMENT ON COLUMN public.funcionarios.cargo IS 'Função exercida pelo funcionário no condomínio.';
COMMENT ON COLUMN public.funcionarios.cpf IS 'Número do Cadastro de Pessoas Físicas do funcionário.';
COMMENT ON COLUMN public.funcionarios.rg IS 'Número do Registro Geral de Identidade do funcionário.';
COMMENT ON COLUMN public.funcionarios.email IS 'Endereço de correio eletrônico de contato do funcionário.';
COMMENT ON COLUMN public.funcionarios.telefone IS 'Número de telefone de contato com 11 dígitos (DDD + Número).';
COMMENT ON COLUMN public.funcionarios.ic_ativo IS 'Indicador de exclusão lógica. S para ativo, N para inativo.';
COMMENT ON COLUMN public.funcionarios.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.funcionarios.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_funcionarios_atualizado_em
BEFORE UPDATE ON public.funcionarios
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();

-- --------------------------------------------------------
-- TABELA: MORADORES
-- --------------------------------------------------------
CREATE TABLE public.moradores (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fk_user BIGINT UNIQUE REFERENCES public.users(id) ON DELETE SET NULL,
    nome VARCHAR(150) NOT NULL,
    cpf VARCHAR(11) UNIQUE NOT NULL,
    rg VARCHAR(20) UNIQUE,
    email VARCHAR(150) UNIQUE NOT NULL,
    telefone NUMERIC(11,0),
    bloco CHAR(1) NOT NULL,
    apartamento INTEGER NOT NULL,
    ic_ativo CHAR(1) DEFAULT 'S' NOT NULL,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT ck_moradores_email CHECK (email LIKE '%@%'),
    CONSTRAINT ck_moradores_apartamento CHECK (apartamento > 0),
    CONSTRAINT ck_moradores_ic_ativo CHECK (ic_ativo IN ('S', 'N'))
);

COMMENT ON TABLE public.moradores IS 'Cadastro dos moradores responsáveis pelas unidades do condomínio. Tamanho inicial estimado: 300 registros. Crescimento anual estimado: 15%.';
COMMENT ON COLUMN public.moradores.id IS 'Identificador artificial único do morador.';
COMMENT ON COLUMN public.moradores.fk_user IS 'Chave estrangeira que vincula o morador aos seus dados de login.';
COMMENT ON COLUMN public.moradores.nome IS 'Nome completo do morador responsável pela unidade.';
COMMENT ON COLUMN public.moradores.cpf IS 'Número do Cadastro de Pessoas Físicas do morador.';
COMMENT ON COLUMN public.moradores.rg IS 'Número do Registro Geral de Identidade do morador.';
COMMENT ON COLUMN public.moradores.email IS 'Endereço de correio eletrônico do morador.';
COMMENT ON COLUMN public.moradores.telefone IS 'Número de telefone de contato com 11 dígitos (DDD + Número).';
COMMENT ON COLUMN public.moradores.bloco IS 'Letra ou número identificador do bloco do apartamento.';
COMMENT ON COLUMN public.moradores.apartamento IS 'Número identificador da unidade do apartamento.';
COMMENT ON COLUMN public.moradores.ic_ativo IS 'Indicador de exclusão lógica. S para ativo, N para inativo.';
COMMENT ON COLUMN public.moradores.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.moradores.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_moradores_atualizado_em
BEFORE UPDATE ON public.moradores
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();

-- --------------------------------------------------------
-- TABELA: VISITANTES
-- --------------------------------------------------------
CREATE TABLE public.visitantes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    morador_id BIGINT NOT NULL REFERENCES public.moradores(id) ON DELETE CASCADE,
    funcionario_id BIGINT NOT NULL REFERENCES public.funcionarios(id),
    nome VARCHAR(150) NOT NULL,
    cpf VARCHAR(11) UNIQUE,
    rg VARCHAR(20) UNIQUE NOT NULL,
    telefone NUMERIC(11,0),
    dt_entrada TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    dt_saida TIMESTAMP,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

COMMENT ON TABLE public.visitantes IS 'Registro de fluxo de entrada e saída de visitantes. Tamanho inicial estimado: 1000 registros. Crescimento anual estimado: 50%.';
COMMENT ON COLUMN public.visitantes.id IS 'Identificador artificial único do visitante.';
COMMENT ON COLUMN public.visitantes.morador_id IS 'Chave estrangeira apontando para o morador que autorizou a entrada.';
COMMENT ON COLUMN public.visitantes.funcionario_id IS 'Chave estrangeira apontando para o funcionário que registrou a entrada.';
COMMENT ON COLUMN public.visitantes.nome IS 'Nome completo do visitante.';
COMMENT ON COLUMN public.visitantes.cpf IS 'Número do Cadastro de Pessoas Físicas do visitante.';
COMMENT ON COLUMN public.visitantes.rg IS 'Número do Registro Geral de Identidade do visitante.';
COMMENT ON COLUMN public.visitantes.telefone IS 'Número de telefone de contato com 11 dígitos (DDD + Número).';
COMMENT ON COLUMN public.visitantes.dt_entrada IS 'Data e hora em que o visitante acessou o condomínio.';
COMMENT ON COLUMN public.visitantes.dt_saida IS 'Data e hora em que o visitante deixou o condomínio.';
COMMENT ON COLUMN public.visitantes.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.visitantes.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_visitantes_atualizado_em
BEFORE UPDATE ON public.visitantes
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();

-- --------------------------------------------------------
-- TABELA: ENCOMENDAS
-- --------------------------------------------------------
CREATE TABLE public.encomendas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    morador_id BIGINT NOT NULL REFERENCES public.moradores(id) ON DELETE CASCADE,
    funcionario_id BIGINT NOT NULL REFERENCES public.funcionarios(id),
    remetente VARCHAR(150) NOT NULL,
    status VARCHAR(20) DEFAULT 'PENDENTE' NOT NULL,
    hora_recebimento_portaria TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    hora_retirada_morador TIMESTAMP,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT ck_encomendas_status CHECK (status IN ('PENDENTE', 'ENTREGUE', 'DEVOLVIDA'))
);

COMMENT ON TABLE public.encomendas IS 'Controle de pacotes recebidos pela portaria. Tamanho inicial estimado: 500 registros. Crescimento anual estimado: 30%.';
COMMENT ON COLUMN public.encomendas.id IS 'Identificador artificial único da encomenda.';
COMMENT ON COLUMN public.encomendas.morador_id IS 'Chave estrangeira do morador destinatário da encomenda.';
COMMENT ON COLUMN public.encomendas.funcionario_id IS 'Chave estrangeira do funcionário que recebeu a encomenda na portaria.';
COMMENT ON COLUMN public.encomendas.remetente IS 'Nome da pessoa ou empresa que enviou a encomenda.';
COMMENT ON COLUMN public.encomendas.status IS 'Situação atual da encomenda. Valores: PENDENTE, ENTREGUE, DEVOLVIDA.';
COMMENT ON COLUMN public.encomendas.hora_recebimento_portaria IS 'Data e hora em que a portaria recebeu o pacote.';
COMMENT ON COLUMN public.encomendas.hora_retirada_morador IS 'Data e hora em que o morador retirou o pacote.';
COMMENT ON COLUMN public.encomendas.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.encomendas.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_encomendas_atualizado_em
BEFORE UPDATE ON public.encomendas
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();

-- --------------------------------------------------------
-- TABELA: RESERVAS
-- --------------------------------------------------------
CREATE TABLE public.reservas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    morador_id BIGINT NOT NULL REFERENCES public.moradores(id) ON DELETE CASCADE,
    local_id BIGINT NOT NULL REFERENCES public.locais(id) ON DELETE RESTRICT,
    data_reserva DATE NOT NULL,
    status VARCHAR(20) DEFAULT 'CONFIRMADA' NOT NULL,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT ck_reservas_status CHECK (status IN ('PENDENTE', 'CONFIRMADA', 'CANCELADA')),
    CONSTRAINT uk_reservas_data_local UNIQUE (local_id, data_reserva)
);

COMMENT ON TABLE public.reservas IS 'Agendamento de áreas comuns pelos moradores. Tamanho inicial estimado: 150 registros. Crescimento anual estimado: 25%.';
COMMENT ON COLUMN public.reservas.id IS 'Identificador artificial único da reserva.';
COMMENT ON COLUMN public.reservas.morador_id IS 'Chave estrangeira indicando o morador que solicitou a reserva.';
COMMENT ON COLUMN public.reservas.local_id IS 'Chave estrangeira apontando para o local reservado.';
COMMENT ON COLUMN public.reservas.data_reserva IS 'Data específica para a qual o local foi reservado.';
COMMENT ON COLUMN public.reservas.status IS 'Situação da reserva. Valores: PENDENTE, CONFIRMADA, CANCELADA.';
COMMENT ON COLUMN public.reservas.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.reservas.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_reservas_atualizado_em
BEFORE UPDATE ON public.reservas
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();

-- --------------------------------------------------------
-- TABELA: RECLAMACOES
-- --------------------------------------------------------
CREATE TABLE public.reclamacoes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fk_morador BIGINT NOT NULL REFERENCES public.moradores(id) ON DELETE CASCADE,
    titulo VARCHAR(100) NOT NULL,
    descricao TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'ABERTA' NOT NULL,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT ck_reclamacoes_status CHECK (status IN ('ABERTA', 'EM_ANALISE', 'RESOLVIDA'))
);

COMMENT ON TABLE public.reclamacoes IS 'Livro de ocorrências digital gerado pelos moradores. Tamanho inicial estimado: 50 registros. Crescimento anual estimado: 10%.';
COMMENT ON COLUMN public.reclamacoes.id IS 'Identificador artificial único da reclamação.';
COMMENT ON COLUMN public.reclamacoes.fk_morador IS 'Chave estrangeira apontando para o morador autor da reclamação.';
COMMENT ON COLUMN public.reclamacoes.titulo IS 'Título resumido do problema relatado.';
COMMENT ON COLUMN public.reclamacoes.descricao IS 'Texto detalhado com o conteúdo da reclamação.';
COMMENT ON COLUMN public.reclamacoes.status IS 'Situação de atendimento. Valores: ABERTA, EM_ANALISE, RESOLVIDA.';
COMMENT ON COLUMN public.reclamacoes.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.reclamacoes.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_reclamacoes_atualizado_em
BEFORE UPDATE ON public.reclamacoes
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();

-- --------------------------------------------------------
-- TABELA: AVISOS
-- --------------------------------------------------------
CREATE TABLE public.avisos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    titulo VARCHAR(100) NOT NULL,
    mensagem TEXT NOT NULL,
    data_expiracao TIMESTAMP,
    ic_ativo CHAR(1) DEFAULT 'S' NOT NULL,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT ck_avisos_ic_ativo CHECK (ic_ativo IN ('S', 'N'))
);

COMMENT ON TABLE public.avisos IS 'Quadro de avisos geral da administração. Tamanho inicial estimado: 20 registros. Crescimento anual estimado: 15%.';
COMMENT ON COLUMN public.avisos.id IS 'Identificador artificial único do aviso.';
COMMENT ON COLUMN public.avisos.titulo IS 'Título de destaque do aviso.';
COMMENT ON COLUMN public.avisos.mensagem IS 'Conteúdo completo do aviso publicado.';
COMMENT ON COLUMN public.avisos.data_expiracao IS 'Data a partir da qual o aviso deixa de ter validade no mural.';
COMMENT ON COLUMN public.avisos.ic_ativo IS 'Indicador de exclusão lógica. S para ativo, N para inativo.';
COMMENT ON COLUMN public.avisos.criado_em IS 'Data e hora da criação do registro.';
COMMENT ON COLUMN public.avisos.atualizado_em IS 'Data e hora da última alteração no registro.';

CREATE TRIGGER tr_avisos_atualizado_em
BEFORE UPDATE ON public.avisos
FOR EACH ROW EXECUTE FUNCTION public.fn_atualiza_timestamp();


-- --------------------------------------------------------
-- TABELA DE HISTÓRICO: TBH_USERS
-- --------------------------------------------------------
CREATE TABLE public.tbh_users (
    id_historico BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ic_acao_registro CHAR(1) NOT NULL,
    dh_acao_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    nr_cpf_usuario_acao VARCHAR(11) NOT NULL,
    
    -- Colunas espelhadas da tabela original
    id_user BIGINT NOT NULL REFERENCES public.users(id),
    categoria VARCHAR(20) NOT NULL,
    cpf VARCHAR(11) NOT NULL,
    senha VARCHAR(255) NOT NULL,
    ic_ativo CHAR(1) NOT NULL,
    criado_em TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP NOT NULL,
    
    CONSTRAINT ck_tbh_users_acao CHECK (ic_acao_registro IN ('I', 'A', 'E'))
);

COMMENT ON TABLE public.tbh_users IS 'Tabela de histórico de ações sobre as credenciais de usuários. Tamanho inicial estimado: 100 registros. Crescimento anual estimado: 15%. Política de expurgo: Registros com mais de 5 anos devem ser arquivados em storage secundário e removidos desta tabela.';
COMMENT ON COLUMN public.tbh_users.id_historico IS 'Chave primária artificial e sequencial da tabela de histórico.';
COMMENT ON COLUMN public.tbh_users.ic_acao_registro IS 'Indicador da ação realizada no registro: I (Inclusão), A (Alteração), E (Exclusão Lógica).';
COMMENT ON COLUMN public.tbh_users.dh_acao_registro IS 'Data e hora em que a ação foi realizada.';
COMMENT ON COLUMN public.tbh_users.nr_cpf_usuario_acao IS 'CPF do usuário logado no sistema que realizou a ação.';
COMMENT ON COLUMN public.tbh_users.id_user IS 'Identificador do registro na tabela original (users).';
COMMENT ON COLUMN public.tbh_users.categoria IS 'Espelho da coluna categoria da tabela original.';
COMMENT ON COLUMN public.tbh_users.cpf IS 'Espelho da coluna cpf da tabela original.';
COMMENT ON COLUMN public.tbh_users.senha IS 'Espelho da coluna senha da tabela original.';
COMMENT ON COLUMN public.tbh_users.ic_ativo IS 'Espelho da coluna ic_ativo da tabela original.';
COMMENT ON COLUMN public.tbh_users.criado_em IS 'Espelho da coluna criado_em da tabela original.';
COMMENT ON COLUMN public.tbh_users.atualizado_em IS 'Espelho da coluna atualizado_em da tabela original.';

-- Gatilho para preenchimento automático do histórico de USERS
CREATE OR REPLACE FUNCTION public.fn_gera_historico_users()
RETURNS TRIGGER AS $$
DECLARE
    v_acao CHAR(1);
    v_cpf_acao VARCHAR(11);
BEGIN
    -- Determina a ação
    IF (TG_OP = 'INSERT') THEN
        v_acao := 'I';
    ELSIF (TG_OP = 'UPDATE') THEN
        -- Verifica se foi uma exclusão lógica
        IF (NEW.ic_ativo = 'N' AND OLD.ic_ativo = 'S') THEN
            v_acao := 'E';
        ELSE
            v_acao := 'A';
        END IF;
    END IF;

    -- Captura o CPF de quem executou (no Supabase, geralmente extraído do JWT da sessão)
    -- Caso não exista contexto (ação interna), utiliza um CPF padrão de sistema
    v_cpf_acao := COALESCE(current_setting('request.jwt.claims', true)::json->>'cpf', '00000000000');

    INSERT INTO public.tbh_users (
        ic_acao_registro, dh_acao_registro, nr_cpf_usuario_acao,
        id_user, categoria, cpf, senha, ic_ativo, criado_em, atualizado_em
    ) VALUES (
        v_acao, CURRENT_TIMESTAMP, v_cpf_acao,
        NEW.id, NEW.categoria, NEW.cpf, NEW.senha, NEW.ic_ativo, NEW.criado_em, NEW.atualizado_em
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_historico_users
AFTER INSERT OR UPDATE ON public.users
FOR EACH ROW EXECUTE FUNCTION public.fn_gera_historico_users();

-- --------------------------------------------------------
-- TABELA DE HISTÓRICO: TBH_MORADORES
-- --------------------------------------------------------
CREATE TABLE public.tbh_moradores (
    id_historico BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ic_acao_registro CHAR(1) NOT NULL,
    dh_acao_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    nr_cpf_usuario_acao VARCHAR(11) NOT NULL,
    
    -- Colunas espelhadas da tabela original
    id_morador BIGINT NOT NULL REFERENCES public.moradores(id),
    fk_user BIGINT,
    nome VARCHAR(150) NOT NULL,
    cpf VARCHAR(11) NOT NULL,
    rg VARCHAR(20),
    email VARCHAR(150) NOT NULL,
    telefone NUMERIC(11,0),
    bloco CHAR(1) NOT NULL,
    apartamento INTEGER NOT NULL,
    ic_ativo CHAR(1) NOT NULL,
    criado_em TIMESTAMP NOT NULL,
    atualizado_em TIMESTAMP NOT NULL,
    
    CONSTRAINT ck_tbh_moradores_acao CHECK (ic_acao_registro IN ('I', 'A', 'E'))
);

COMMENT ON TABLE public.tbh_moradores IS 'Tabela de histórico de ações sobre o cadastro de moradores. Tamanho inicial estimado: 300 registros. Crescimento anual estimado: 25%. Política de expurgo: Manter o histórico completo; expurgo não aplicável devido a requisitos legais de auditoria condominial.';
COMMENT ON COLUMN public.tbh_moradores.id_historico IS 'Chave primária artificial e sequencial da tabela de histórico.';
COMMENT ON COLUMN public.tbh_moradores.ic_acao_registro IS 'Indicador da ação realizada no registro: I (Inclusão), A (Alteração), E (Exclusão Lógica).';
COMMENT ON COLUMN public.tbh_moradores.dh_acao_registro IS 'Data e hora em que a ação foi realizada.';
COMMENT ON COLUMN public.tbh_moradores.nr_cpf_usuario_acao IS 'CPF do usuário logado no sistema que realizou a ação.';
COMMENT ON COLUMN public.tbh_moradores.id_morador IS 'Identificador do registro na tabela original (moradores).';
COMMENT ON COLUMN public.tbh_moradores.fk_user IS 'Espelho da coluna fk_user da tabela original. Não possui constraint de FK neste histórico.';
COMMENT ON COLUMN public.tbh_moradores.nome IS 'Espelho da coluna nome da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.cpf IS 'Espelho da coluna cpf da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.rg IS 'Espelho da coluna rg da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.email IS 'Espelho da coluna email da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.telefone IS 'Espelho da coluna telefone da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.bloco IS 'Espelho da coluna bloco da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.apartamento IS 'Espelho da coluna apartamento da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.ic_ativo IS 'Espelho da coluna ic_ativo da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.criado_em IS 'Espelho da coluna criado_em da tabela original.';
COMMENT ON COLUMN public.tbh_moradores.atualizado_em IS 'Espelho da coluna atualizado_em da tabela original.';

-- Gatilho para preenchimento automático do histórico de MORADORES
CREATE OR REPLACE FUNCTION public.fn_gera_historico_moradores()
RETURNS TRIGGER AS $$
DECLARE
    v_acao CHAR(1);
    v_cpf_acao VARCHAR(11);
BEGIN
    IF (TG_OP = 'INSERT') THEN
        v_acao := 'I';
    ELSIF (TG_OP = 'UPDATE') THEN
        IF (NEW.ic_ativo = 'N' AND OLD.ic_ativo = 'S') THEN
            v_acao := 'E';
        ELSE
            v_acao := 'A';
        END IF;
    END IF;

    -- Captura o CPF do contexto transacional
    v_cpf_acao := COALESCE(current_setting('request.jwt.claims', true)::json->>'cpf', '00000000000');

    INSERT INTO public.tbh_moradores (
        ic_acao_registro, dh_acao_registro, nr_cpf_usuario_acao,
        id_morador, fk_user, nome, cpf, rg, email, telefone, bloco, apartamento, ic_ativo, criado_em, atualizado_em
    ) VALUES (
        v_acao, CURRENT_TIMESTAMP, v_cpf_acao,
        NEW.id, NEW.fk_user, NEW.nome, NEW.cpf, NEW.rg, NEW.email, NEW.telefone, NEW.bloco, NEW.apartamento, NEW.ic_ativo, NEW.criado_em, NEW.atualizado_em
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_historico_moradores
AFTER INSERT OR UPDATE ON public.moradores
FOR EACH ROW EXECUTE FUNCTION public.fn_gera_historico_moradores();